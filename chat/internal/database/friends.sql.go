// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: friends.sql

package database

import (
	"context"

	"github.com/google/uuid"
)

const find_friends = `-- name: Find_friends :many
SELECT
 CASE 
  WHEN followed_by=$1 THEN followed
  WHEN followed=$1 THEN followed_by
 END::varchar(12) AS friend, room_id
FROM friends
`

type Find_friendsRow struct {
	Friend string
	RoomID uuid.UUID
}

func (q *Queries) Find_friends(ctx context.Context, followedBy string) ([]Find_friendsRow, error) {
	rows, err := q.db.QueryContext(ctx, find_friends, followedBy)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Find_friendsRow
	for rows.Next() {
		var i Find_friendsRow
		if err := rows.Scan(&i.Friend, &i.RoomID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const find_room = `-- name: Find_room :many
SELECT room_id FROM friends 
WHERE (followed_by=$1 AND followed=$2) 
OR 
(followed_by=$2 AND followed=$1)
`

type Find_roomParams struct {
	FollowedBy string
	Followed   string
}

func (q *Queries) Find_room(ctx context.Context, arg Find_roomParams) ([]uuid.UUID, error) {
	rows, err := q.db.QueryContext(ctx, find_room, arg.FollowedBy, arg.Followed)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []uuid.UUID
	for rows.Next() {
		var room_id uuid.UUID
		if err := rows.Scan(&room_id); err != nil {
			return nil, err
		}
		items = append(items, room_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
